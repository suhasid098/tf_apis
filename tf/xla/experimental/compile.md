description: Builds an operator that compiles and runs computation with XLA. (deprecated)

<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf.xla.experimental.compile" />
<meta itemprop="path" content="Stable" />
</div>

# tf.xla.experimental.compile

<!-- Insert buttons and diff -->

<table class="tfo-notebook-buttons tfo-api nocontent" align="left">

</table>

<a target="_blank" class="external" href="/code/stable/tensorflow/python/compiler/xla/xla.py">View source</a>



Builds an operator that compiles and runs `computation` with XLA. (deprecated)

<section class="expandable">
  <h4 class="showalways">View aliases</h4>
  <p>
<b>Compat aliases for migration</b>
<p>See
<a href="https://www.tensorflow.org/guide/migrate">Migration guide</a> for
more details.</p>
<p>`tf.compat.v1.xla.experimental.compile`</p>
</p>
</section>

<pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link">
<code>tf.xla.experimental.compile(
    computation, inputs=None
)
</code></pre>



<!-- Placeholder for "Used in" -->

Deprecated: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
xla.experimental.compile is deprecated. Consider using tf.function(jit_compile=True)

NOTE: In eager mode, `computation` will have <a href="../../../tf/function.md"><code>@tf.function</code></a> semantics.

<!-- Tabular view -->
 <table class="responsive fixed orange">
<colgroup><col width="214px"><col></colgroup>
<tr><th colspan="2"><h2 class="add-link">Args</h2></th></tr>

<tr>
<td>
`computation`
</td>
<td>
A Python function that builds a computation to apply to the
input. If the function takes n inputs, 'inputs' should be a list of n
tensors.

`computation` may return a list of operations and tensors.  Tensors must
come before operations in the returned list.  The return value of
`compile` is a list of tensors corresponding to the tensors from the
output of `computation`.

All `Operation`s returned from `computation` will be executed when
evaluating any of the returned output tensors.
</td>
</tr><tr>
<td>
`inputs`
</td>
<td>
A list of inputs or `None` (equivalent to an empty list). Each input
can be a nested structure containing values that are convertible to
tensors. Note that passing an N-dimension list of compatible values will
result in a N-dimension list of scalar tensors rather than a single Rank-N
tensors. If you need different behavior, convert part of inputs to tensors
with <a href="../../../tf/convert_to_tensor.md"><code>tf.convert_to_tensor</code></a>.
</td>
</tr>
</table>



<!-- Tabular view -->
 <table class="responsive fixed orange">
<colgroup><col width="214px"><col></colgroup>
<tr><th colspan="2"><h2 class="add-link">Returns</h2></th></tr>
<tr class="alt">
<td colspan="2">
Same data structure as if computation(*inputs) is called directly with some
exceptions for correctness. Exceptions include:
  1) None output: a NoOp would be returned which control-depends on
     computation.
  2) Single value output: A tuple containing the value would be returned.
  3) Operation-only outputs: a NoOp would be returned which
     control-depends on computation.
</td>
</tr>

</table>



<!-- Tabular view -->
 <table class="responsive fixed orange">
<colgroup><col width="214px"><col></colgroup>
<tr><th colspan="2"><h2 class="add-link">Raises</h2></th></tr>

<tr>
<td>
`RuntimeError`
</td>
<td>
if called when eager execution is enabled.
</td>
</tr>
</table>



#### Known issues:

When a tf.random operation is built with XLA, the implementation doesn't
  pass the user provided seed to the XLA compiler. As such, the XLA compiler
  generates a random number and uses it as a seed when compiling the
  operation. This implementation causes a violation of the Tensorflow
  defined semantics in two aspects. First, changing the value of the user
  defined seed doesn't change the numbers generated by the operation.
  Second, when a seed is not specified, running the program multiple times
  will generate the same numbers.
